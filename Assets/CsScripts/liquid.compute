#pragma kernel ComputeDensityPressure
#pragma kernel ComputeForces
#pragma kernel Integrate
#pragma kernel ComputeColliders
#pragma kernel putIntoTexture
#pragma kernel SmoothPath
#pragma kernel Blur

struct SPHParticle
{
    float3 position;
    float3 velocity;
    float3 force;
    float density;
    float pressure;
};

struct MeshTriangle
{
    float3 p1WPos;
    float3 p2WPos;
    float3 p3WPos;
    float3 normal;
    float3 tangent;
    float3 binormal; 
};


RWStructuredBuffer<SPHParticle> particles;
StructuredBuffer<MeshTriangle> tris;
RWTexture3D<float4> liqText;

//Passed from SPHFluid.cs
int triCount;

int particleCount;
int colliderCount;
int texRes;
float smoothingRadius;
float smoothingRadiusSq;
float gas;
float restDensity;
float mass;
float radius;
float particleDrag;
float particleViscosity;
float damping;
float deltaTime;
float4 gravity;

float3 penetrationNormal;
float penetrationLength;
float3 penetrationPosition;

#define PI 3.1415926536
#define PARTICLETHREADCOUNT 64
#define eps 0.01

bool Intersect(MeshTriangle tri, float3 position)
{
    bool inter = false;
    float3 colliderProjection = tri.p1WPos - position;

    penetrationLength = abs(dot(colliderProjection, tri.normal)) - (radius / 2.0);
    penetrationPosition = position;

    if (penetrationLength < 0.0)
    {
        float2 p1 = tri.p1WPos;
        float2 p2 = tri.p2WPos;
        float2 p3 = tri.p3WPos;

        float a = ((p2.y - p3.y) * (position.x - p3.x) + (p3.x - p2.x) * (position.y - p3.y)) / ((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));
        float b = ((p3.y - p1.y) * (position.x - p3.x) + (p1.x - p3.x) * (position.y - p3.y)) / ((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));
        float c = 1 - a - b;
        if (0 - eps <= a && a <= 1 + eps && 0 - eps <= b && b <= 1 + eps && 0 - eps <= c && c <= 1 + eps)
        {
            inter = true;
        }
    }
    return inter;
}

float3 DampVelocity(MeshTriangle tri, float3 velocity, float drag)
{
    float3 newVelocity = dot(velocity, penetrationNormal) * penetrationNormal * damping
                    + dot(velocity, tri.tangent) * tri.tangent * drag
                    + dot(velocity, tri.binormal) * tri.binormal * drag;

    float3 forward = float3(0, 0, 1);
    float3 right = float3(1, 0, 0);
    float3 up = float3(0, 1, 0);

    return dot(newVelocity, forward) * forward
            + dot(newVelocity, right) * right
            + dot(newVelocity, up) * up;
}

[numthreads(PARTICLETHREADCOUNT, 1, 1)]
void ComputeDensityPressure(uint3 id : SV_DispatchThreadID)
{
    SPHParticle particle = particles[id.x];

    particle.density = 0.0f;

    for (int j = 0; j < particleCount; j++)
    {
        float3 relativePosition = particles[j].position - particle.position;
        float rP2 = dot(relativePosition, relativePosition);

        if (rP2 < smoothingRadiusSq)
        {
            particle.density += mass * (315.0f / (64.0f * PI * pow(smoothingRadius, 9.0f))) * pow(smoothingRadiusSq - rP2, 3.0f);
        }
    }

    particle.pressure = gas * (particle.density - restDensity);

    particles[id.x] = particle;
}

[numthreads(PARTICLETHREADCOUNT, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID)
{
    float3 forcePressure = 0;
    float3 forceViscosity = 0;
    SPHParticle particle = particles[id.x];

    for (int j = 0; j < particleCount; j++)
    {
        if (id.x == (uint) j)
            continue;

        SPHParticle particleJ = particles[j];

        float3 relativePosition = particleJ.position - particle.position;
        float rP2 = dot(relativePosition, relativePosition);
        
        if (rP2 < smoothingRadiusSq)
        {
            float r = length(relativePosition);
            float3 rPN = normalize(relativePosition);

            forcePressure += -rPN * mass * (particle.pressure + particleJ.pressure) / (2.0f * particleJ.density) * (-45.0f / (PI * pow(smoothingRadius, 6.0f))) * pow(smoothingRadius - r, 2.0f);
            forceViscosity += particleViscosity * mass * (particleJ.velocity - particle.velocity) / particleJ.density * (45.0f / (PI * pow(smoothingRadius, 6.0f))) * (smoothingRadius - r);
        }
    }

    float3 forceGravity = gravity.xyz * particle.density * gravity.w;

    particle.force = forcePressure + forceViscosity + forceGravity;

    particles[id.x] = particle;
}

[numthreads(PARTICLETHREADCOUNT, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID)
{
    SPHParticle particle = particles[id.x];

    particle.velocity += deltaTime * particle.force / particle.density;
    particle.position += deltaTime * particle.velocity;

    particles[id.x] = particle;
}

float3 DampVelocity(float3 u, float3 r, float3 n, float3 velocity, float drag)
{
    float3 newVelocity = dot(velocity, n) * n * damping
                    + dot(velocity, r) * r * drag
                    + dot(velocity, u) * u * drag;

    float3 forward = float3(0, 0, 1);
    float3 right = float3(1, 0, 0);
    float3 up = float3(0, 1, 0);

    return dot(newVelocity, forward) * forward
            + dot(newVelocity, right) * right
            + dot(newVelocity, up) * up;
}

[numthreads(PARTICLETHREADCOUNT, 1, 1)]
void ComputeColliders(uint3 id : SV_DispatchThreadID)
{
    float bound = 12;
    float h = bound;
    float l = -bound;
    
    float3 u = float3(0, 1, 0);
    float3 f = float3(0, 0, 1);
    float3 r = float3(1, 0, 0);
    
    if (particles[id.x].position.x > h)
    {
        particles[id.x].velocity = DampVelocity(u, f, r, particles[id.x].velocity, 1.0 - particleDrag);
        particles[id.x].position.x = h;// - penetrationNormal; // * abs(penetrationLength);
    }
    if (particles[id.x].position.x < l)
    {
        particles[id.x].velocity = DampVelocity(u, f, r, particles[id.x].velocity, 1.0 - particleDrag);
        particles[id.x].position.x = l; // - penetrationNormal; // * abs(penetrationLength);
    }
    if (particles[id.x].position.y > h)
    {
        particles[id.x].velocity = DampVelocity(f, r, -u, particles[id.x].velocity, 1.0 - particleDrag);
        particles[id.x].position.y = h; // - penetrationNormal; // * abs(penetrationLength);
    }
    if (particles[id.x].position.y < l)
    {
        particles[id.x].velocity = DampVelocity(f, r, u, particles[id.x].velocity, 1.0 - particleDrag);
        particles[id.x].position.y = h; // - penetrationNormal; // * abs(penetrationLength);
    }
    if (particles[id.x].position.z > h)
    {
        particles[id.x].velocity = DampVelocity(u, r, -f, particles[id.x].velocity, 1.0 - particleDrag);
        particles[id.x].position.z = l; // - penetrationNormal; // * abs(penetrationLength);
    }
    if (particles[id.x].position.z < l)
    {
        particles[id.x].velocity = DampVelocity(u, r, f, particles[id.x].velocity, 1.0 - particleDrag);
        particles[id.x].position.z = h; // - penetrationNormal; // * abs(penetrationLength);
    }
    for (int i = 0; i < triCount; i++)
    {
        if (Intersect(tris[i], particles[id.x].position))
        {
            particles[id.x].velocity = DampVelocity(tris[i], particles[id.x].velocity, 1.0 - particleDrag);
            particles[id.x].position = penetrationPosition - tris[i].normal * abs(penetrationLength);
        }
    }
}

[numthreads(PARTICLETHREADCOUNT, 1, 1)]
void putIntoTexture(uint3 id : SV_DispatchThreadID)
{
    float3 pos = round(((particles[id.x].position / 25) + 0.5) * texRes);
    float4 col = float4(1, 1, 1, 1);
    //col.a = pos.z * 5;

    int ps = 2;
    for (int l = -ps; l < ps; l++)
    {
        for (int h = -ps; h < ps; h++)
        {
            for (int w = -ps; w < ps; w++)
            {
                float hyp = sqrt(l * l + h * h + w * w);
                if (hyp <= ps)
                {
                    liqText[pos + int3(l, h, w)] = col;

                }
            }
        }
    }
}

static int kSize = 0;

[numthreads(8, 8, 8)]
void SmoothPath(uint3 id : SV_DispatchThreadID)
{
    liqText[id.xyz] -= 0.01;
}

[numthreads(8, 8, 8)]
void Blur(uint3 id : SV_DispatchThreadID)
{
    float4 result = float4(0, 0, 0, 0);

    for (int x = -kSize; x <= kSize; x++)
    {
        for (int y = -kSize; y <= kSize; y++)
        {
            for (int z = -kSize; z <= kSize; z++)
            {
                result += liqText[id.xyz + int3(x, y, z)] / float(pow(2 * kSize + 1, 3));
            }
        }
    }
    liqText[id.xyz] = result;
}