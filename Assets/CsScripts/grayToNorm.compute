// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel genNormMap

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> gray;
RWTexture2D<float4> nMap;
int texRes;

static float grayScale = 24;

[numthreads(15,15,1)]
void genNormMap (uint3 id : SV_DispatchThreadID)
{
    float3 normalCol;
    //add the white values of either side and divide by 2, then map to -1 to 1 and then normalize
    //compare to texel above and below
    float a;
    float b;
    float curPCol = gray[id.xy].r;
    if ((int) id.y < texRes - 1)
    {
        a = curPCol - gray[id.xy + int2(0, 1)].r;
    }
    else
    {
        a = curPCol - gray[id.xy + int2(0, -1)].r;
    }
    if ((int) id.y > 0)
    {
        b = curPCol - gray[id.xy + int2(0, -1)].r;
    }
    else
    {
        b = curPCol - gray[id.xy + int2(0, 1)].r;
    }
    float avGrayab = ((a + b) / 2) * grayScale;
    float l;
    float r;
    if ((int) id.x < texRes - 1)
    {
        r = curPCol - gray[id.xy + int2(1, 0)].r;
    }
    else
    {
        r = curPCol - gray[id.xy + int2(-1, 0)].r;
    }
    if ((int) id.x > 0)
    {
        l = curPCol - gray[id.xy + int2(-1, 0)].r;
    }
    else
    {
        l = curPCol - gray[id.xy + int2(1, 0)].r;
    }
    float avGraylr = ((l + r) / 2) * grayScale;
    
    //avGrayab = avGrayab * 2.0 - 1.0;
    //avGraylr = avGraylr * 2.0 - 1.0;
    normalCol = float3(avGraylr, avGrayab, 1);
    normalCol = normalCol * 0.5 + 0.5;
    //normalCol *= normalCol;
    nMap[id.xy] = float4(normalCol, 1.0);
    //nMap[id.xy] = gray[id.xy];

}
